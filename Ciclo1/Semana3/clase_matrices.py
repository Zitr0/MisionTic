# -*- coding: utf-8 -*-
"""Clase_matrices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ECT_xrpzpv0LlYbUo-JZvhmZNKqP4tvR

**MINISTERIO DE LAS TECNOLOGÍAS DE LA INFORMACIÓN**
**UNIVERSIDAD DE ANTIOQUIA**
CURSO: FUNDAMENTOS DE PROGRAMACIÓN EN PYTHON
DOCENTE: **Ing. AURA XIMENA GONZÁLEZ CELY**
Descripción: El material expuesto en esta hoja de Google Colaboratory contiene información acerca de las listas, métodos, listas de listas, matrices con Numpy y clase matriz.

Conceptos básicos de las listas en Python y métodos para operar listas. Tomado de: Curso Fundamental programming in Python- CISCO
"""

###____________________________________________________________________LISTAS_____________________________________________________________________________###
val=[]
numeros = [111, 7, 2, 1]    #Creación de la lista
print(numeros)              #Imprime lista
print("Longitud de la lista: ",len(numeros))         #Impresión de la longitud de la lista


###

numeros.append(4)           #Agrega número en la última posición
print("Método append: ",numeros)
print(len(numeros))
###

numeros.insert(0,222)     #Inserta en una posición determinada el valor
print(numeros)
print(len(numeros))
#
numeros.insert(1,333)
print("Método insert: ",numeros)

###
print("Index method: ",numeros.index(333))

###
del(numeros[-1])
print("Eliminado el último dato de la lista: ",numeros)

###
for i in range(len(numeros)):
  print("Ciclo for que recorre cada posición de la lista: ",numeros[i])

###
numeros.pop(4)
print("Método pop: ",numeros)

###
numeros=[333,11,333,12,2]
numeros.remove(333)
print("Método remove: ",numeros)

###
numeros.extend("s") #Añade elementos de un string, lista o tupla al final de la lista
print("Método extend: ",numeros)
###
newList=numeros[:]
print("Elementos guardados en la nueva lista: ",newList)

"""Listas de listas o multilistas en Python. A partir del concepto de lista, se crean matrices.
Tomado de: https://naps.com.mx/blog/multilistas-en-python-listas-de-listas/
"""

###____________________________________________________________________LISTAS DE LISTAS_____________________________________________________________________###

#Creando multilistas con el método append
lista = []
lista.append([2,4,6])
print("Lista actual: ",lista)
lista.append([8,10,12])
lista.append(4)
print ("Matriz de dos filas y tres columnas:\n ",lista)
print("Posición [0,0]: ",lista[0][0])
lista[0][0]=4
#Creando matriz con ciclo for
"""
Creamos una lista vacía (lista2=[ ]), y usamos un for que vaya de 0 al número de filas deseado (for i in range(2)). 
Dentro del for, agregamos a la lista un elemento que será una lista vacía (lista2.append([ ]),
 y usamos un for que vaya de 0 al número de columnas deseado (for j in range(3)). 
 Dentro de ese segundo for, agregamos un cero, a la lista que está en el último elemento creado (lista2[i].append(0)).
"""
lista2 = []
for i in range(2):
	lista2.append([])
	for j in range(3):
		lista2[i].append(0)	
print ("Matriz con ciclo for de 2 filas y 3 columnas: ",lista2)

#Expresión generadora para crear la matriz
"""
El código anterior crea una variable  de tipo lista (iterador = [ ) 
y dentro se utiliza un for (for i in range(3) que va a ir de 0 a 2. 
A la izquierda de ese for, se especifica el valor que se va a generar,
 en éste caso dentro de la lista. (‘Hello’). El resultado es una lista con tres valores ‘Hello’.
"""
iterador = ['Hello' for i in range(3)]
print (iterador)

print ("Lista con variable que está iterando: ",[i for i in range(6) ])

lista3 = [[0 for col in range(3)] for row in range(2)]
print ("Multilista a partir de expresión generadora: ",lista3)

"""https://jakevdp.github.io/PythonDataScienceHandbook/02.02-the-basics-of-numpy-arrays.html
A partir de ahora se procede a analizar las matrices a partir del uso de la librería Numpy y sus características. 
"""

###____________________________________________________________________MATRICES CON NUMPY____________________________________________________________________###

"""
La manipulación de datos en Python es casi sinónimo de la manipulación de matrices NumPy.
Esta sección presentará varios ejemplos del uso de la manipulación de 
matrices NumPy para acceder a datos y submatrices, y para dividir, remodelar y unir las matrices. 
Si bien los tipos de operaciones que se muestran aquí pueden parecer un poco áridos y pedantes, 
comprenden los componentes básicos de muchos otros ejemplos utilizados a lo largo del libro. ¡Conócelos bien!

* Atributos de las matrices: determinación del tamaño, la forma, el consumo de memoria y los tipos de datos de las matrices
* Indexación de matrices: obtención y configuración del valor de elementos de matriz individuales
* División de matrices: obtención y configuración de submatrices más pequeñas dentro de una matriz más grande
* Remodelación de matrices: Cambiar la forma de una matriz dada
* Unir y dividir matrices: combinar varias matrices en una y dividir una matriz en muchas
"""

import numpy as np  #Importación de librería con sobrenombre


###____________________________________________________________________ATRIBUTOS_____________________________________________________________________________###


x1 = np.random.randint(10, size=6)  # Arreglo de una dimensión
x2 = np.random.randint(10, size=(3, 4))  # Two-dimensional array
x3 = np.random.randint(10, size=(5, 4, 5))  # Three-dimensional array

print("Arreglo de una dimensión: ",x1)
print("Arreglo de dos dimensiones:\n ",x2)
print("Arreglo de tres dimensiones:\n ",x3)

"""
Cada matriz tiene atributos ndim (el número de dimensiones), forma (el tamaño de cada dimensión) y tamaño (el tamaño total de la matriz):
"""

print("x3 ndim:\n ", x3.ndim)
print("x3 shape:\n", x3.shape)
print("x3 size:\n ", x3.size)

print("dtype:\n", x3.dtype)       #Tipo de dato del array

"""
Otros atributos incluyen "itemsize", que enumera el tamaño (en bytes) de cada elemento de la matriz,
 y "nbytes" que enumera el tamaño total (en bytes) de la matriz:
"""

print("itemsize:", x3.itemsize, "bytes")
print("nbytes:", x3.nbytes, "bytes")

###Buscar el máximo valor de un array
np_array = np.array((1, 5, 9, 3, 7, 2, 0))
print("Array para buscar el máximo valor: ",np_array)
print(np.where(max(np_array) == np_array))
print(np.max(np_array))

#Buscar elemento de un array
np_array = np.array(((1, 5), (9, 3), (7, 2)))
print("Arreglo para buscar elemento 5:\n ",np_array)
print("Posición del array-elemento a buscar: ",np.where(np_array == 5))

###____________________________________________________________________INDEXACIÓN DE MATRICES________________________________________________________________###

"""
En una matriz unidimensional, se puede acceder al i-ésimo valor (contando desde cero)
especificando el índice deseado entre corchetes, al igual que con las listas de Python:
"""
print("Matriz x1:\n ",x1)
print("x1[0]: ",x1[0])
print("x1[4]: ",x1[4])
print("x1[-1]: ",x1[-1])
print("x1[-2]: ",x1[-2])

"""
En una matriz multidimensional, se puede acceder a los elementos mediante una tupla de índices separados por comas:
"""
print("Matriz x2:\n ",x2)
print("x2[0, 0]: ",x2[0, 0])
print("x2[2, 0]: ",x2[2, 0])
print("x2[2, -1]: ",x2[2, -1])

"""
Los valores también se pueden modificar utilizando cualquiera de las notación de índice anterior:
"""
x2[0, 0] = 12
print("Matriz x2_cambio de valor:\n ",x2)


x1[0] = 3.14159  # Valor truncado
print("Matriz x1_valor truncado:\n ",x1)

###____________________________________________________________________DIVISIÓN DE MATRICES_________________________________________________________________###

"""
Así como podemos usar corchetes para acceder a elementos individuales de la matriz, 
también podemos usarlos para acceder a submatrices con la notación de sector,
 marcada por el carácter de dos puntos (:). 
 La sintaxis de segmentación de NumPy sigue la de la lista estándar de Python; 
 para acceder a una porción de una matriz x, use esto:
 x[start:stop:step]
"""
#Subarreglos de una dimensión
x = np.arange(10)
print("x:\n ",x)

print("Primeros cinco elementos: ",x[:5])  
print("Elementos desde la quinta posición: ",x[5:])  
print("Elementos del medio: ",x[4:7])  
print("Todos los elementos múltiplos del valor establecido: ",x[::4])  
print("Elementos desde la primera posición avanzando de a dos: ",x[1::2])  
print("Elementos al revés: ",x[::-1])  # all elements, reversed

###____________________________________________________________________SUBARREGLOS MULTIDIMENSIONALES_________________________________________________________________###

print("Matriz x2:\n ",x2)
print("Impresión 2 filas y 3 columnas:\n ",x2[:2, :3])
print("3 flas y 2 columnas:\n ",x2[:3, ::2] )
print("Matriz al revés:\n",x2[::-1, ::-1])
print("Primera columna de x2:\n",x2[:, 0])
print("Primera fila de x2:\n",x2[0, :])
print("Equivalente a fila cero: ",x2[0]) 

#Subarreglos
print("Matriz original x2:\n ",x2)
x2_sub = x2[:2, :2]
print("Subarreglo x2 de 2*2 :\n ",x2_sub)

x2_sub[0, 0] = 99
print("Cambio de dato en la posición 0,0 del subarreglo:\n ",x2_sub)

print("Matriz con subarreglo y cambios:\n ",x2)

#Copias de arreglos
x2_sub_copy = x2[:2, :2].copy()
print("Arreglo copia del subarreglo:\n",x2_sub_copy)

x2_sub_copy[0, 0] = 42
print("Cambio de dato en pos 0,0 de la copia del subarreglo:\n ",x2_sub_copy)

###______________________________________________________________REORGANIZACIÓN DE MATRICES_________________________________________________________________###

#Reshaping arrays
grid = np.arange(1, 10).reshape((3, 3))
print("Matriz 3*3 con valores organizados entre 1 y 10:\n ",grid)

"""
Tenga en cuenta que para que esto funcione, el tamaño de la matriz inicial debe coincidir
 con el tamaño de la matriz reformada. Siempre que sea posible, el método de remodelación 
 utilizará una vista sin copia de la matriz inicial, pero con búferes de memoria no
 contiguos este no es siempre el caso.
"""
x = np.array([1, 2, 3])
print("Arreglo de una dimensión:\n ",x)
# row vector via reshape
print("Fila 1_método reshape: ",x.reshape((1, 3)))

# row vector via newaxis
print("Nuevo eje: ",x[np.newaxis, :])

# column vector via reshape
print("Columna 1 método reshape:\n ",x.reshape((3, 1)))

# column vector via newaxis
print("Columna con método newaxis:\n ",x[:, np.newaxis])

print("Método mat:\n ",np.array(np.mat('1 2; 3 4')))

print("Arreglo una dimensión type complex: ",np.array([1, 2, 3], dtype=complex))

###______________________________________________________________CONCATENACIÓN Y DIVISIÓN DE MATRICES_________________________________________________________________###

#___Concatenación____#
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
print("Concatena arreglos x y y:\n ",np.concatenate([x, y]))

z = [99, 99, 99]
print("Concatena x, y, z: ",np.concatenate([x, y, z]))

grid = np.array([[1, 2, 3],
                 [4, 5, 6]])
print("Concatena grid con grid:\n ",np.concatenate([grid, grid]))

print("Concatena grid con grid a lo largo del segundo eje:\n ",np.concatenate([grid, grid], axis=1))

x = np.array([1, 2, 3])
grid = np.array([[9, 8, 7],
                 [6, 5, 4]])
print("Arreglo x:\n",x)
print("Matriz grid:\n",grid)
# vertically stack the arrays
print("Apila verticalmente el arreglo x y la matriz grid:\n ",np.vstack([x, grid]))

y = np.array([[99],
              [99]])
print("Matriz y:\n",y)
print("Apila horizontalmente el arreglo x y la matriz grid:\n ",np.hstack([grid, y]))

#____División____
x = [1, 2, 3, 99, 99, 3, 2, 1]
print("Arreglo x para ser dividido:\n ",x)
x1, x2, x3 = np.split(x, [3, 5])
print("División de arreglo en 3:",x1, x2, x3)

grid = np.arange(16).reshape((4, 4))
print("Arreglo:\n ",grid)

upper, lower = np.vsplit(grid, [2])
print("Upper:\n ",upper)
print("lower:\n",lower)

left, right = np.hsplit(grid, [2])
print("Left:\n ",left)
print("right:\n",right)

###____________________________________________________________________CLASE MATRIZ (MinTIC)________________________________________________________________###
class Matriz():
  def __init__(self,m,n):
    self.m=m
    self.n=n
    self.mat=[]*m+1
    for i in range(m+1):
      a=[0]*(n+1)
      self.mat.append(a)

  def numeroFilas(self):
    return self.m

  def numeroColumnas(self):
    return self.n
  
  def imprimeMatrizPorFilas(self,mensaje="Matriz sin nombre: "):
    print("\n",mensaje)
    for i in range(1,self.m+1):
      for j in range(1,self.n+1):
        print(self.mat[i][j],"\t",end="")
        print()

  def imprimeMatrizPorColumnas(self,mensaje="Matriz sin nombre: "):
    print("\n",mensaje)
    for i in range(1,self.n+1):
      for j in range(1,self.m+1):
        print(self.mat[j][i],"\t",end="")
        print()
  
  def intercambiarFilas(self,i,j):
    for k in range(1,self.n):
      aux= self.mat[i][k]
      self.mat[i][k]=self.mat[j][k]
      self.mat[j][k]=aux
  
  def intercambiarFilas(self,i,j):
    for k in range(1,self.m):
      aux= self.mat[k][i]
      self.mat[k][j]=self.mat[k][i]
      self.mat[k][i]=aux

  def sumarFilas(self):
    v=vector(self.m)
    for i in range(1,self.m+1):
      s=0
      for j in range(1,self.n+1):
        s=s+self.mat [i][j]
      v.agregarDato(s)
    return v
  
  def sumarColumnas(self):
    v=vector(self.n)
    for i in range(1,self.n+1):
      s=0
      for j in range(1,self.m+1):
        s=s+self.mat [j][i]
      v.agregarDato(s)
    return v
  def traspuesta(self):
    c=matriz(self.n,self.m)
    for i in range(1,self.m+1):
      for j in range(1,self.n+1):
        c.mat[j][i]=self.mat[i][j]
    return c